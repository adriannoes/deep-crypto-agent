"""Base strategy classes and interfaces."""
from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Any, Optional

import pandas as pd


class StrategyDirection(Enum):
    """Strategy direction (bullish/bearish)."""

    CALL = "call"  # Bullish - expect price to rise
    PUT = "put"  # Bearish - expect price to fall


@dataclass
class StrategySignal:
    """Trading signal generated by a strategy."""

    symbol: str
    side: str  # 'buy' or 'sell'
    quantity: Optional[Decimal] = None
    price: Optional[Decimal] = None
    confidence: Decimal = Decimal("1.0")  # 0.0 to 1.0
    stop_loss: Optional[Decimal] = None
    take_profit: Optional[Decimal] = None
    metadata: dict[str, Any] = None

    def __post_init__(self):
        """Initialize metadata if not provided."""
        if self.metadata is None:
            self.metadata = {}


class BaseStrategy(ABC):
    """
    Base class for trading strategies.

    All strategies must inherit from this class and implement
    the required abstract methods.
    """

    def __init__(
        self,
        name: str,
        direction: StrategyDirection = StrategyDirection.CALL,
        **kwargs: Any,
    ):
        """
        Initialize base strategy.

        Args:
            name: Strategy name/identifier
            direction: Strategy direction (CALL for bullish, PUT for bearish)
            **kwargs: Additional strategy-specific parameters
        """
        self.name = name
        self.direction = direction
        self.enabled = True
        self.params = kwargs

    @abstractmethod
    async def generate_signals(
        self,
        symbol: str,
        market_data: pd.DataFrame,
        current_date: datetime,
        positions: dict[str, Any],
        **kwargs: Any,
    ) -> list[StrategySignal]:
        """
        Generate trading signals based on market data and current state.

        Args:
            symbol: Trading symbol
            market_data: Historical market data (OHLCV DataFrame)
            current_date: Current date/time
            positions: Current positions dictionary
            **kwargs: Additional context (e.g., portfolio value, cash)

        Returns:
            List of StrategySignal objects (can be empty)
        """
        pass

    @abstractmethod
    def fit_day(
        self,
        today: pd.Series,
        market_data: pd.DataFrame,
        **kwargs: Any,
    ) -> Optional[StrategySignal]:
        """
        Evaluate strategy for a specific day (legacy compatibility).

        This method provides compatibility with the legacy AbuFactorBuyBase
        interface where strategies evaluate day-by-day.

        Args:
            today: Current day's market data (pd.Series)
            market_data: Historical market data (pd.DataFrame)
            **kwargs: Additional context

        Returns:
            StrategySignal if signal generated, None otherwise
        """
        pass

    def validate_signal(self, signal: StrategySignal) -> bool:
        """
        Validate a generated signal before execution.

        Args:
            signal: Strategy signal to validate

        Returns:
            True if signal is valid, False otherwise
        """
        if not self.enabled:
            return False

        if signal.side not in ["buy", "sell"]:
            return False

        if signal.quantity is not None and signal.quantity <= 0:
            return False

        if signal.price is not None and signal.price <= 0:
            return False

        return True

    def get_direction_multiplier(self) -> Decimal:
        """
        Get direction multiplier for profit calculation.

        Returns:
            1.0 for CALL (bullish), -1.0 for PUT (bearish)
        """
        return Decimal("1.0") if self.direction == StrategyDirection.CALL else Decimal("-1.0")

    def __str__(self) -> str:
        """String representation of strategy."""
        return f"{self.__class__.__name__}(name={self.name}, direction={self.direction.value})"

    def __repr__(self) -> str:
        """String representation of strategy."""
        return self.__str__()

